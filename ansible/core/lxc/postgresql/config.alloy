
local.file_match "syslog" {
  path_targets = [{
    __path__ = "/var/log/syslog",
    job      = "syslog",
    instance = constants.hostname,
    log_type = "system",
  }]
}

// --- Read dmesg (kernel ring buffer) ---
// Note: dmesg is typically read via command, not file
// We'll use journald for kernel logs or read /var/log/kern.log
local.file_match "kernel" {
  path_targets = [{
    __path__ = "/var/log/kern.log",
    job      = "kernel",
    instance = constants.hostname,
    log_type = "kernel",
  }]
}

// --- Read auth logs ---
local.file_match "auth" {
  path_targets = [{
    __path__ = "/var/log/auth.log",
    job      = "auth",
    instance = constants.hostname,
    log_type = "auth",
  }]
}

loki.process "parse_syslog" {
 
  stage.regex {
    expression = "^(?P<timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<hostname>\\S+)\\s+(?P<service>\\w+)(\\[(?P<pid>\\d+)\\])?:\\s+(?P<message>.*)"
  }

  // Extract log level from message
  stage.regex {
    source    = "message"
    expression = "(?i)\\b(?P<log_level>emerg|alert|crit|critical|err|error|warn|warning|notice|info|debug)\\b"
  }

  // Parse systemd journal format if present
  stage.regex {
    expression = "(?i)(?P<service>systemd|kernel|sshd|sudo|cron|docker).*?(?P<log_level>error|warning|info|debug|critical|fatal)"
  }

  // Publish labels
  stage.labels {
    values = {
      hostname   = "",
      service    = "",
      pid        = "",
      log_level  = "",
      job        = "",
      instance   = "",
      log_type   = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Process kernel logs ---
loki.process "parse_kernel" {
  // Parse kernel log format:
  // [timestamp] message
  stage.regex {
    expression = "^(?P<timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<hostname>\\S+)\\s+kernel:\\s+\\[\\s*(?P<kernel_time>[\\d\\.]+)\\]\\s+(?P<message>.*)"
  }

  // Extract log level from kernel messages
  stage.regex {
    source    = "message"
    expression = "^<(?P<priority>\\d)>|(?i)\\b(?P<log_level>emerg|alert|crit|err|warn|notice|info|debug)\\b"
  }

  // Map kernel priority to log level
  stage.template {
    source   = "priority"
    template = "{{ if eq .priority \"0\" }}emerg{{ else if eq .priority \"1\" }}alert{{ else if eq .priority \"2\" }}crit{{ else if eq .priority \"3\" }}err{{ else if eq .priority \"4\" }}warn{{ else if eq .priority \"5\" }}notice{{ else if eq .priority \"6\" }}info{{ else }}debug{{ end }}"
  }

  stage.labels {
    values = {
      hostname    = "",
      kernel_time = "",
      log_level   = "",
      priority    = "",
      job         = "",
      instance    = "",
      log_type    = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Read syslog file ---
loki.source.file "syslog" {
  targets    = local.file_match.syslog.targets
  forward_to = [loki.process.parse_syslog.receiver]
}

// --- Read kernel log file ---
loki.source.file "kernel" {
  targets    = local.file_match.kernel.targets
  forward_to = [loki.process.parse_kernel.receiver]
}

// --- Read auth log file ---
loki.source.file "auth" {
  targets    = local.file_match.auth.targets
  forward_to = [loki.process.parse_syslog.receiver]
}

// --- Alternative: Use journald for dmesg (recommended) ---
loki.source.journal "dmesg" {
  format_as_json = true
  max_age        = "12h"
  
  // Filter for kernel messages only
  matches = "_TRANSPORT=kernel"
  
  labels = {
    job      = "dmesg",
    instance = constants.hostname,
    log_type = "kernel",
  }

  forward_to = [loki.process.parse_journald.receiver]
}

// --- Process journald logs ---
loki.process "parse_journald" {
  // Extract fields from journald JSON
  stage.json {
    expressions = {
      message       = "MESSAGE",
      priority      = "PRIORITY",
      syslog_id     = "SYSLOG_IDENTIFIER",
      systemd_unit  = "_SYSTEMD_UNIT",
      hostname      = "_HOSTNAME",
    }
  }

  // Map journald priority (0-7) to log level
  stage.template {
    source   = "priority"
    template = "{{ if eq .priority \"0\" }}emerg{{ else if eq .priority \"1\" }}alert{{ else if eq .priority \"2\" }}crit{{ else if eq .priority \"3\" }}err{{ else if eq .priority \"4\" }}warn{{ else if eq .priority \"5\" }}notice{{ else if eq .priority \"6\" }}info{{ else }}debug{{ end }}"
  }

  stage.labels {
    values = {
      log_level    = "",
      syslog_id    = "",
      systemd_unit = "",
      hostname     = "",
      job          = "",
      instance     = "",
      log_type     = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}



// --- Read PostgreSQL logs ---
local.file_match "postgresql" {
  path_targets = [{
    __path__ = "/var/log/postgresql/postgresql-16-main.log",
    job      = "postgresql",
    instance = constants.hostname,
    log_type = "database",
    db_type  = "postgresql",
    db_version = "16",
  }]
}

// --- Process PostgreSQL logs ---
loki.process "parse_postgresql" {
  // Parse PostgreSQL log format:
  // 2025-11-19 15:39:47.428 UTC [192] LOG:  checkpoint starting: time
  stage.regex {
    expression = "^(?P<timestamp>\\d{4}-\\d{2}-\\d{2}\\s+\\d{2}:\\d{2}:\\d{2}\\.\\d{3})\\s+(?P<timezone>\\w+)\\s+\\[(?P<pid>\\d+)\\]\\s+(?P<log_level>\\w+):\\s+(?P<message>.*)"
  }

  // Extract additional context from message
  stage.regex {
    source     = "message"
    expression = "(?P<operation>checkpoint|connection|statement|error|warning|vacuum|autovacuum|deadlock|lock|recovery|replication|archive|backup|restore)"
  }

  // Extract checkpoint details if present
  stage.regex {
    source     = "message"
    expression = "checkpoint (?P<checkpoint_type>starting|complete)"
  }

  // Extract connection information
  stage.regex {
    source     = "message"
    expression = "connection (?P<connection_action>received|authorized|authenticated)"
  }

  // Extract database and user from connection logs
  stage.regex {
    source     = "message"
    expression = "database=(?P<database>\\w+).*user=(?P<user>\\w+)"
  }

  // Extract query duration if present
  stage.regex {
    source     = "message"
    expression = "duration:\\s+(?P<duration_ms>[\\d.]+)\\s+ms"
  }

  // Extract error codes (SQLSTATE)
  stage.regex {
    source     = "message"
    expression = "(?P<error_code>[A-Z0-9]{5}):"
  }

  // Map PostgreSQL log levels to standard levels
  stage.template {
    source   = "log_level"
    template = "{{ .log_level | ToLower }}"
  }

  // Normalize log level names
  stage.template {
    source   = "log_level"
    template = "{{ if eq .log_level \"fatal\" }}critical{{ else if eq .log_level \"panic\" }}emergency{{ else }}{{ .log_level }}{{ end }}"
  }

  // Add timestamp as label for better querying
  stage.timestamp {
    source = "timestamp"
    format = "2006-01-02 15:04:05.000"
  }

  // Publish labels
  stage.labels {
    values = {
      log_level        = "",
      pid              = "",
      timezone         = "",
      operation        = "",
      checkpoint_type  = "",
      connection_action = "",
      database         = "",
      user             = "",
      error_code       = "",
      job              = "",
      instance         = "",
      log_type         = "",
      db_type          = "",
      db_version       = "",
    }
  }

  // Add metrics extraction for monitoring
  stage.metrics {
    metric.counter {
      name        = "postgresql_log_lines_total"
      description = "Total number of PostgreSQL log lines"
      prefix      = "alloy_"
      
      match_all = true
      
      action = "inc"
    }

    metric.counter {
      name        = "postgresql_checkpoints_total"
      description = "Total number of PostgreSQL checkpoints"
      prefix      = "alloy_"
      
      source = "checkpoint_type"
      
      action = "inc"
    }

    metric.histogram {
      name        = "postgresql_query_duration_seconds"
      description = "PostgreSQL query duration in seconds"
      prefix      = "alloy_"
      
      source = "duration_ms"
      
      buckets = [0.001, 0.01, 0.1, 0.5, 1, 5, 10, 30, 60]
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Read PostgreSQL log file ---
loki.source.file "postgresql" {
  targets    = local.file_match.postgresql.targets
  forward_to = [loki.process.parse_postgresql.receiver]
}

// --- Write to Loki ---
loki.write "local" {
  endpoint {
    url = "http://192.168.30.21:3100/loki/api/v1/push"
  }
}