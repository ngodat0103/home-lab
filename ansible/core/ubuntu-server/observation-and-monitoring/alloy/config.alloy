// ###############################
// #### Logging Configuration ####
// ###############################

// --- Discover Docker containers ---
discovery.docker "linux" {
  host = "unix:///var/run/docker.sock"
}

// --- Relabel rules for Docker (strip leading "/" from container name; add instance) ---
discovery.relabel "logs_integrations_docker" {
  targets = []

  // container_name: "/nginx" -> "nginx"
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/(.*)"
    target_label  = "container_name"
  }

  // instance: set to host running Alloy
  rule {
    target_label = "instance"
    replacement  = constants.hostname
  }
}

// --- Log processing pipeline for Docker: extract log_level ---
loki.process "parse_docker_level" {
  // 1) Try JSON logs first: capture a variety of common level fields
  stage.json {
    expressions = {
      log_level       = "level",
      severity        = "severity",
      log_dot_level   = "log.level",
      lvl             = "lvl",
      message         = "message",
      msg             = "msg",
    }
  }

  // 2) If JSON didn't have it, try to lift alternatives into "log_level"
  stage.regex {
    expression = "(?i)(?:^|[\\s\\{\\[,])severity[=:\"\\s]*?(?P<log_level>[a-z]+)"
  }

  stage.regex {
    expression = "(?i)(?:^|[\\s\\{\\[,])lvl[=:\"\\s]*?(?P<log_level>[a-z]+)"
  }

  // 3) Plain-text patterns
  stage.regex {
    expression = "^[\\[\\(](?P<log_level>[A-Za-z]+)[\\]\\)]"
  }

  stage.regex {
    expression = "(?i)(?:^|\\s)level\\s*[:=]\\s*(?P<log_level>[A-Za-z]+)"
  }

  stage.regex {
    expression = "^(?P<log_level>(?i:trace|debug|info|warn|warning|error|fatal|critical))\\b[:\\-\\s]"
  }

  // 4) Parse Nginx/Traefik access logs
  stage.regex {
    expression = "^(?P<client_ip>\\S+) \\S+ \\S+ \\[(?P<timestamp>[^\\]]+)\\] \"(?P<method>[A-Z]+) (?P<path>[^ ]+) (?P<protocol>[^\"]+)\" (?P<status>\\d+) (?P<bytes_sent>\\d+) \"(?P<referer>[^\"]*)\" \"(?P<user_agent>[^\"]*)\" (?P<request_id>\\d+) \"(?P<router_name>[^\"]+)\" \"(?P<upstream_url>[^\"]+)\" (?P<duration>\\d+ms)"
  }

  // 5) Publish labels
  stage.labels {
    values = {
      log_level      = "",
      container_name = "",
      instance       = "",
      client_ip      = "",
      method         = "",
      path           = "",
      status         = "",
      router_name    = "",
      duration       = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Read Docker logs + apply relabel + send to process pipeline ---
loki.source.docker "default" {
  host          = "unix:///var/run/docker.sock"
  targets       = discovery.docker.linux.targets
  relabel_rules = discovery.relabel.logs_integrations_docker.rules
  forward_to    = [loki.process.parse_docker_level.receiver]
}

// ########################################
// #### Ubuntu System Logs Collection ####
// ########################################

// --- Read /var/log/syslog ---
local.file_match "syslog" {
  path_targets = [{
    __path__ = "/var/log/syslog",
    job      = "syslog",
    instance = constants.hostname,
    log_type = "system",
  }]
}

// --- Read dmesg (kernel ring buffer) ---
// Note: dmesg is typically read via command, not file
// We'll use journald for kernel logs or read /var/log/kern.log
local.file_match "kernel" {
  path_targets = [{
    __path__ = "/var/log/kern.log",
    job      = "kernel",
    instance = constants.hostname,
    log_type = "kernel",
  }]
}

// --- Read auth logs ---
local.file_match "auth" {
  path_targets = [{
    __path__ = "/var/log/auth.log",
    job      = "auth",
    instance = constants.hostname,
    log_type = "auth",
  }]
}

// --- Process syslog format logs ---
loki.process "parse_syslog" {
  // Parse standard syslog format:
  // Nov 11 10:30:45 hostname service[pid]: message
  stage.regex {
    expression = "^(?P<timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<hostname>\\S+)\\s+(?P<service>\\w+)(\\[(?P<pid>\\d+)\\])?:\\s+(?P<message>.*)"
  }

  // Extract log level from message
  stage.regex {
    source    = "message"
    expression = "(?i)\\b(?P<log_level>emerg|alert|crit|critical|err|error|warn|warning|notice|info|debug)\\b"
  }

  // Parse systemd journal format if present
  stage.regex {
    expression = "(?i)(?P<service>systemd|kernel|sshd|sudo|cron|docker).*?(?P<log_level>error|warning|info|debug|critical|fatal)"
  }

  // Publish labels
  stage.labels {
    values = {
      hostname   = "",
      service    = "",
      pid        = "",
      log_level  = "",
      job        = "",
      instance   = "",
      log_type   = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Process kernel logs ---
loki.process "parse_kernel" {
  // Parse kernel log format:
  // [timestamp] message
  stage.regex {
    expression = "^(?P<timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<hostname>\\S+)\\s+kernel:\\s+\\[\\s*(?P<kernel_time>[\\d\\.]+)\\]\\s+(?P<message>.*)"
  }

  // Extract log level from kernel messages
  stage.regex {
    source    = "message"
    expression = "^<(?P<priority>\\d)>|(?i)\\b(?P<log_level>emerg|alert|crit|err|warn|notice|info|debug)\\b"
  }

  // Map kernel priority to log level
  stage.template {
    source   = "priority"
    template = "{{ if eq .priority \"0\" }}emerg{{ else if eq .priority \"1\" }}alert{{ else if eq .priority \"2\" }}crit{{ else if eq .priority \"3\" }}err{{ else if eq .priority \"4\" }}warn{{ else if eq .priority \"5\" }}notice{{ else if eq .priority \"6\" }}info{{ else }}debug{{ end }}"
  }

  stage.labels {
    values = {
      hostname    = "",
      kernel_time = "",
      log_level   = "",
      priority    = "",
      job         = "",
      instance    = "",
      log_type    = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Read syslog file ---
loki.source.file "syslog" {
  targets    = local.file_match.syslog.targets
  forward_to = [loki.process.parse_syslog.receiver]
}

// --- Read kernel log file ---
loki.source.file "kernel" {
  targets    = local.file_match.kernel.targets
  forward_to = [loki.process.parse_kernel.receiver]
}

// --- Read auth log file ---
loki.source.file "auth" {
  targets    = local.file_match.auth.targets
  forward_to = [loki.process.parse_syslog.receiver]
}

// --- Alternative: Use journald for dmesg (recommended) ---
loki.source.journal "dmesg" {
  format_as_json = true
  max_age        = "12h"
  
  // Filter for kernel messages only
  matches = "_TRANSPORT=kernel"
  
  labels = {
    job      = "dmesg",
    instance = constants.hostname,
    log_type = "kernel",
  }

  forward_to = [loki.process.parse_journald.receiver]
}

// --- Process journald logs ---
loki.process "parse_journald" {
  // Extract fields from journald JSON
  stage.json {
    expressions = {
      message       = "MESSAGE",
      priority      = "PRIORITY",
      syslog_id     = "SYSLOG_IDENTIFIER",
      systemd_unit  = "_SYSTEMD_UNIT",
      hostname      = "_HOSTNAME",
    }
  }

  // Map journald priority (0-7) to log level
  stage.template {
    source   = "priority"
    template = "{{ if eq .priority \"0\" }}emerg{{ else if eq .priority \"1\" }}alert{{ else if eq .priority \"2\" }}crit{{ else if eq .priority \"3\" }}err{{ else if eq .priority \"4\" }}warn{{ else if eq .priority \"5\" }}notice{{ else if eq .priority \"6\" }}info{{ else }}debug{{ end }}"
  }

  stage.labels {
    values = {
      log_level    = "",
      syslog_id    = "",
      systemd_unit = "",
      hostname     = "",
      job          = "",
      instance     = "",
      log_type     = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// --- Write to Loki ---
loki.write "local" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
}